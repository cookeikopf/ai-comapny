name: Orchestrator

on:
  issues:
    types: [opened, labeled, edited, reopened]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to orchestrate"
        required: true

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  orchestrate:
    runs-on: ubuntu-latest

    # WICHTIG: Concurrency nur auf Job-Ebene, mit safe Fallback auf run_id
    concurrency:
      group: orchestrate-${{ github.event.issue.number || github.run_id }}
      cancel-in-progress: true

    steps:
      - uses: actions/checkout@v4

      # Kurzdiagnose im Log
      - name: Debug context
        run: |
          echo "event_name=${{ github.event_name }}"
          echo "issue_number=${{ github.event.issue.number }}"
          echo "ref=${{ github.ref }}"
          echo "repo=${{ github.repository }}"

      # Synthetic Event für manuellen Start
      - name: Build synthetic event for workflow_dispatch
        if: ${{ github.event_name == 'workflow_dispatch' }}
        id: synth
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = Number(core.getInput('issue_number'));
            const { data: issue } = await github.rest.issues.get({ ...context.repo, issue_number });
            if (!(issue.labels || []).some(l => (l.name||l)==='task:agent')) {
              await github.rest.issues.addLabels({ ...context.repo, issue_number, labels: ['task:agent'] });
            }
            const fs = require('fs'), path = require('path');
            const p = path.join(process.env.RUNNER_TEMP, 'event.json');
            fs.writeFileSync(p, JSON.stringify({ issue }), 'utf8');
            core.setOutput('event_path', p);

      # Label-Guard
      - name: Ensure label 'task:agent'
        id: labelcheck
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const issue_number = context.eventName === 'workflow_dispatch'
              ? Number(core.getInput('issue_number'))
              : context.payload.issue.number;
            const { data: issue } = await github.rest.issues.get({ ...context.repo, issue_number });
            return (issue.labels || []).some(l => (l.name||l)==='task:agent') ? 'true' : 'false';

      - name: Comment missing label and exit
        if: ${{ steps.labelcheck.outputs.result != 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.eventName === 'workflow_dispatch'
              ? Number(core.getInput('issue_number'))
              : context.payload.issue.number;
            await github.rest.issues.createComment({
              ...context.repo, issue_number,
              body: "ℹ️ Orchestrator übersprungen: Bitte Label `task:agent` setzen (ein-/ausblenden reicht)."
            });

      - uses: actions/setup-python@v5
        if: ${{ steps.labelcheck.outputs.result == 'true' }}
        with:
          python-version: '3.11'

      - name: Run orchestrator
        if: ${{ steps.labelcheck.outputs.result == 'true' }}
        id: orch
        env:
          GITHUB_EVENT_PATH: ${{ github.event_name == 'workflow_dispatch' && steps.synth.outputs.event_path || github.event_path }}
        run: python scripts/orchestrate.py

      - name: Commit plan files
        if: ${{ steps.labelcheck.outputs.result == 'true' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add reports/board/ || true
          git commit -m "chore(plan): add/update plan for #${{ github.event.issue.number || 'manual' }}" || echo "No changes"
          git push || true

      - name: Comment plan link on issue
        if: ${{ steps.labelcheck.outputs.result == 'true' }}
        uses: actions/github-script@v7
        env:
          PLAN_PATH: ${{ steps.orch.outputs.plan_path }}
        with:
          script: |
            const issue_number = context.eventName === 'workflow_dispatch'
              ? Number(core.getInput('issue_number'))
              : context.payload.issue.number;
            const body = `Plan erzeugt/aktualisiert: \`${process.env.PLAN_PATH || "(kein Plan)"}\``;
            await github.rest.issues.createComment({ ...context.repo, issue_number, body });

      # Agenten-Dispatch (volle Pfade) + Run-Erkennung
      - name: Trigger agents (repo_dispatch + workflow_dispatch + detection)
        if: ${{ steps.labelcheck.outputs.result == 'true' }}
        id: dispatch
        uses: actions/github-script@v7
        env:
          PLAN_PATH: ${{ steps.orch.outputs.plan_path }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const issue_number = context.eventName === 'workflow_dispatch'
              ? Number(core.getInput('issue_number'))
              : context.payload.issue.number;

            const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number });
            const title = (issue.title || "").toLowerCase();
            const ref = (context.ref && context.ref.replace("refs/heads/",""))
                     || (context.payload?.repository?.default_branch) || "main";

            const wantsEngineer = /(parse|script|normalize|gate|test|engineer|pipeline)/.test(title);
            const wantsGrowth   = /(outreach|draft|growth|message|email|template)/.test(title);
            const fireEngineer = wantsEngineer || (!wantsEngineer && !wantsGrowth);
            const fireGrowth   = wantsGrowth;

            const payloadBase = {
              issue_number,
              plan_path: process.env.PLAN_PATH || "",
              issue_title: issue.title || ""
            };

            async function dispatchAndWait(tag, wfPath, waitSeconds) {
              const start = Date.now();
              try { await github.rest.repos.createDispatchEvent({ owner, repo, event_type: tag, client_payload: payloadBase }); }
              catch (e) { core.info(`repository_dispatch ${tag} failed: ${e.message}`); }
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner, repo, workflow_id: wfPath, ref,
                  inputs: { issue_number: String(issue_number), plan_path: payloadBase.plan_path, issue_title: payloadBase.issue_title }
                });
              } catch (e) { core.info(`workflow_dispatch ${wfPath} failed: ${e.message}`); }
              const endBy = Date.now() + waitSeconds*1000;
              while (Date.now() < endBy) {
                try {
                  const runs = await github.rest.actions.listWorkflowRuns({ owner, repo, workflow_id: wfPath, event: "workflow_dispatch", per_page: 1 });
                  const run = runs.data.workflow_runs?.[0];
                  if (run && new Date(run.created_at).getTime() >= start) return true;
                } catch (e) { core.info(`listWorkflowRuns ${wfPath} failed: ${e.message}`); }
                await new Promise(r => setTimeout(r, 1000));
              }
              return false;
            }

            let engineerOk = true, growthOk = true;
            if (fireEngineer) engineerOk = await dispatchAndWait("agent-engineer", ".github/workflows/agent-engineer.yml", 20);
            if (fireGrowth)   growthOk   = await dispatchAndWait("agent-growth",   ".github/workflows/agent-growth.yml",   20);

            core.info(`RUN DETECTED: engineer=${engineerOk} growth=${growthOk}`);
            core.setOutput("NEED_FALLBACK_ENGINEER", engineerOk ? "false" : "true");
            core.setOutput("NEED_FALLBACK_GROWTH",   growthOk   ? "false" : "true");

      # Fallback Engineer
      - name: Engineer fallback change
        if: ${{ steps.dispatch.outputs.NEED_FALLBACK_ENGINEER == 'true' }}
        run: |
          mkdir -p reports/agent_runs
          FILE="reports/agent_runs/orchestrator-fallback-engineer-issue-${{ github.event.issue.number || 'manual' }}.md"
          [ -f "$FILE" ] || { echo "# Orchestrator fallback (Engineer)" > "$FILE"; echo "Plan: ${{ steps.orch.outputs.plan_path }}" >> "$FILE"; }

      - name: Fallback PR (Engineer)
        if: ${{ steps.dispatch.outputs.NEED_FALLBACK_ENGINEER == 'true' }}
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore(fallback): engineer PR for issue ${{ github.event.issue.number || 'manual' }}"
          branch: "agent/engineer/issue-${{ github.event.issue.number || 'manual' }}"
          title: "Engineer: Fallback-Änderungen für #${{ github.event.issue.number || 'manual' }}"
          body: |
            Plan: `${{ steps.orch.outputs.plan_path }}`
            Automatischer Engineer-Fallback (Dispatch nicht erkannt).
            ${{ github.event.issue.number && format('Closes #{0}', github.event.issue.number) || '' }}
          labels: agent:engineer, ready-for-review
          signoff: true
          delete-branch: true

      # Fallback Growth
      - name: Growth fallback change
        if: ${{ steps.dispatch.outputs.NEED_FALLBACK_GROWTH == 'true' }}
        run: |
          mkdir -p drafts/outreach reports/agent_runs
          [ -f drafts/outreach/template.md ] || cat > drafts/outreach/template.md << 'MD'
          # Outreach Draft (v1)

          **Zielkunden:** B2B-Leads aus Parsing-Pipeline
          **CTA:** 15-min Call oder 2-Min-Demo

          ## Version A (Kurz)
          Hi {{first_name}}, wir haben ein kleines Tool gebaut, das {{pain_point}} in {{X}} Minuten automatisiert.
          Darf ich dir in 2 Screens zeigen, wie?

          ## Version B (Value-first)
          Hey {{first_name}}, mir ist bei {{company}} aufgefallen: {{trigger}}.
          Wir haben {{benefit}} mit {{proof}} erreicht. Soll ich dir eine 2-Min-Demo schicken?

          — {{sender}}
          MD
          [ -f drafts/README.md ] || echo -e "# Drafts\nDeterministische Vorlagen. Keine PII/Secrets. Änderungen per PR." > drafts/README.md
          FILE="reports/agent_runs/orchestrator-fallback-growth-issue-${{ github.event.issue.number || 'manual' }}.md"
          [ -f "$FILE" ] || { echo "# Orchestrator fallback (Growth)" > "$FILE"; echo "Plan: ${{ steps.orch.outputs.plan_path }}" >> "$FILE"; }

      - name: Fallback PR (Growth)
        if: ${{ steps.dispatch.outputs.NEED_FALLBACK_GROWTH == 'true' }}
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "feat(growth): fallback outreach drafts for issue ${{ github.event.issue.number || 'manual' }}"
          branch: "agent/growth/issue-${{ github.event.issue.number || 'manual' }}"
          title: "Growth: Fallback-Drafts für #${{ github.event.issue.number || 'manual' }}"
          body: |
            Plan: `${{ steps.orch.outputs.plan_path }}`
            Automatischer Growth-Fallback (Dispatch nicht erkannt).
            ${{ github.event.issue.number && format('Closes #{0}', github.event.issue.number) || '' }}
          labels: agent:growth, ready-for-review
          signoff: true
          delete-branch: true
