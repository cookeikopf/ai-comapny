name: Orchestrator

on:
  issues:
    types: [opened, labeled, edited]   # <— opened hinzugefügt

concurrency:
  group: orchestrate-${{ github.event.issue.number }}
  cancel-in-progress: true             # <— doppelte Läufe abbrechen

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  orchestrate:
    # nur laufen, wenn das Issue tatsächlich das Label trägt
    if: contains(github.event.issue.labels.*.name, 'task:agent')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Run orchestrator
        id: orch
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: python scripts/orchestrate.py

      - name: Commit plan files
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add reports/board/ || true
          git commit -m "chore(plan): add/update plan for #${{ github.event.issue.number }}" || echo "No changes"
          git push || true

      - name: Comment plan link on issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.payload.issue.number;
            const planPath = process.env.PLAN_PATH || "(kein Plan gefunden)";
            const body = `Plan erzeugt/aktualisiert: \`${planPath}\``;
            await github.rest.issues.createComment({ ...context.repo, issue_number, body });
        env:
          PLAN_PATH: ${{ steps.orch.outputs.plan_path }}


      - name: Trigger agents (repo_dispatch + workflow_dispatch + check)
        id: dispatch
        uses: actions/github-script@v7
        env:
          PLAN_PATH: ${{ steps.orch.outputs.plan_path }}
        with:
          script: |
            const {owner, repo} = context.repo;
            const issue = context.payload.issue;
            const title = (issue.title || "").toLowerCase();
            const ref   = context.payload.repository?.default_branch || "main";

            const wantsEngineer = /(parse|script|normalize|gate|test|engineer|pipeline)/.test(title);
            const wantsGrowth   = /(outreach|draft|growth|message|email|template)/.test(title);

            // Fallback: wenn nichts erkannt → Engineer feuern
            const fireEngineer  = wantsEngineer || (!wantsEngineer && !wantsGrowth);
            const fireGrowth    = wantsGrowth;

            const payloadBase = {
              issue_number: issue.number,
              plan_path: process.env.PLAN_PATH || "",
              issue_title: issue.title || "",
            };

            async function dispatchAndWait(tag, wfPath, waitSeconds) {
              const start = Date.now();
              try {
                await github.rest.repos.createDispatchEvent({
                  owner, repo, event_type: tag, client_payload: payloadBase
                });
                console.log(`repository_dispatch ${tag} OK`);
              } catch (e) {
                console.log(`repository_dispatch ${tag} failed: ${e.message}`);
              }
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner, repo, workflow_id: wfPath, ref,
                  inputs: {
                    issue_number: String(issue.number),
                    plan_path: payloadBase.plan_path,
                    issue_title: payloadBase.issue_title
                  }
                });
                console.log(`workflow_dispatch ${wfPath} OK`);
              } catch (e) {
                console.log(`workflow_dispatch ${wfPath} failed: ${e.message}`);
              }
              const endBy = Date.now() + (waitSeconds * 1000);
              while (Date.now() < endBy) {
                try {
                  const runs = await github.rest.actions.listWorkflowRuns({
                    owner, repo, workflow_id: wfPath, event: "workflow_dispatch", per_page: 1
                  });
                  const run = runs.data.workflow_runs?.[0];
                  if (run && new Date(run.created_at).getTime() >= start) {
                    console.log(`Detected run for ${wfPath}: ${run.html_url}`);
                    return true;
                  }
                } catch (e) {
                  console.log(`listWorkflowRuns ${wfPath} failed: ${e.message}`);
                }
                await new Promise(r => setTimeout(r, 1000));
              }
              return false;
            }

            let ENGINEER_OK = true;
            if (fireEngineer) ENGINEER_OK = await dispatchAndWait("agent-engineer", ".github/workflows/agent-engineer.yml", 20);
            let GROWTH_OK = true;
            if (fireGrowth)   GROWTH_OK   = await dispatchAndWait("agent-growth",   ".github/workflows/agent-growth.yml",   20);

            core.setOutput("ENGINEER_OK", ENGINEER_OK ? "true" : "false");
            core.setOutput("GROWTH_OK",   GROWTH_OK   ? "true" : "false");
            core.setOutput("NEED_FALLBACK_ENGINEER", ENGINEER_OK ? "false" : "true");
            core.setOutput("NEED_FALLBACK_GROWTH",   GROWTH_OK   ? "false" : "true");

      - name: Prepare growth fallback
        if: ${{ steps.dispatch.outputs.NEED_FALLBACK_GROWTH == 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Write growth fallback files
        if: ${{ steps.dispatch.outputs.NEED_FALLBACK_GROWTH == 'true' }}
        run: |
          mkdir -p drafts/outreach reports/agent_runs
          if [ ! -f drafts/outreach/template.md ]; then
            cat > drafts/outreach/template.md << 'MD'
# Outreach Draft (v1)

**Zielkunden:** B2B-Leads aus Parsing-Pipeline  
**CTA:** 15-min Call oder 2-Min-Demo

## Version A (Kurz)
Hi {{first_name}}, wir haben ein kleines Tool gebaut, das {{pain_point}} in {{X}} Minuten automatisiert.
Darf ich dir in 2 Screens zeigen, wie?

## Version B (Value-first)
Hey {{first_name}}, mir ist bei {{company}} aufgefallen: {{trigger}}.
Wir haben {{benefit}} mit {{proof}} erreicht. Soll ich dir eine 2-Min-Demo schicken?

— {{sender}}
MD
          fi
          if [ ! -f drafts/README.md ]; then
            cat > drafts/README.md << 'MD'
# Drafts
Deterministische Vorlagen. Keine PII/Secrets. Änderungen per PR.
MD
          fi
          FILE="reports/agent_runs/growth-fallback-issue-${{ github.event.issue.number }}.md"
          if [ ! -f "$FILE" ]; then
            echo "# Growth fallback for Issue #${{ github.event.issue.number }}" > "$FILE"
            echo "Plan: ${{ steps.orch.outputs.plan_path }}" >> "$FILE"
          fi

      - name: Fallback PR (Growth)
        if: ${{ steps.dispatch.outputs.NEED_FALLBACK_GROWTH == 'true' }}
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "feat(growth): fallback outreach drafts for issue #${{ github.event.issue.number }}"
          branch: "agent/growth/issue-${{ github.event.issue.number }}"
          title: "Growth: Fallback-Drafts für #${{ github.event.issue.number }}"
          body: |
            Plan: `${{ steps.orch.outputs.plan_path }}`
            Automatischer Fallback, da Growth-Dispatch nicht erkannt wurde.
          labels: agent:growth, ready-for-review
          signoff: true
          delete-branch: true
      - name: Prepare fallback
        if: ${{ steps.dispatch.outputs.NEED_FALLBACK_ENGINEER == 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Write fallback file
        if: ${{ steps.dispatch.outputs.NEED_FALLBACK_ENGINEER == 'true' }}
        run: |
          mkdir -p reports/agent_runs
          FILE="reports/agent_runs/orchestrator-fallback-issue-${{ github.event.issue.number }}.md"
          if [ ! -f "$FILE" ]; then
            echo "# Orchestrator fallback for Issue #${{ github.event.issue.number }}" > "$FILE"
            echo "Plan: ${{ steps.orch.outputs.plan_path }}" >> "$FILE"
          fi

      - name: Fallback PR (Engineer)
        if: ${{ steps.dispatch.outputs.NEED_FALLBACK_ENGINEER == 'true' }}
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore(fallback): orchestrator PR for issue #${{ github.event.issue.number }}"
          branch: "agent/fallback/issue-${{ github.event.issue.number }}"
          title: "Fallback PR für #${{ github.event.issue.number }}"
          body: |
            Plan: `${{ steps.orch.outputs.plan_path }}`
            Dispatch zu Agenten fehlgeschlagen – Fallback-PR erstellt.
          labels: agent:engineer, ready-for-review
          signoff: true
          delete-branch: true
